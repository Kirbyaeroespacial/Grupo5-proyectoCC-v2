# CAMBIOS IMPLEMENTADOS - Sistema Satélite

## Resumen de Correcciones

Se han restaurado dos funcionalidades críticas que se habían perdido:

### 1. **MODO MANUAL DEL POTENCIÓMETRO** ✅

#### Problema Original:
- El potenciómetro no controlaba el servo cuando se activaba el modo manual desde la GUI
- La GUI enviaba el comando `4:m` pero el sistema no respondía correctamente

#### Solución Implementada:

**En GROUND STATION:**
```cpp
// Variables nuevas
bool manualMode = false;          // Indica si estamos en modo manual
int lastPotAngle = -1;            // Evita duplicados
const unsigned long delay_ang = 500;  // 500ms para lectura más frecuente

// En prot4() - Detecta cambio de modo desde GUI
void prot4(String valor) {
  if (valor == "a") {
    manualMode = false;
    Serial.println("Modo AUTO activado desde GUI");
  } else if (valor == "m") {
    manualMode = true;
    Serial.println("Modo MANUAL activado desde GUI");
  }
}

// En loop() - Control del potenciómetro
if (manualMode) {
  // Solo enviar si el ángulo ha cambiado ±2 grados
  if (abs(angle - lastPotAngle) > 2) {
    sendWithChecksum("5:" + String(angle));
    lastPotAngle = angle;
  }
}
```

**En SATÉLITE:**
```cpp
// handleCommand() mejorado
else if (cmd == "4:m") {
  autoDistance = false;
  motor.write(manualTargetAngle);
  servoAngle = manualTargetAngle;
  Serial.println("Modo MANUAL activado");
}

else if (cmd.startsWith("5:")) {
  int ang = constrain(cmd.substring(2).toInt(), 0, 180);
  manualTargetAngle = ang;
  if (!autoDistance) {  // Si está en manual, mover inmediatamente
    motor.write(manualTargetAngle);
    servoAngle = manualTargetAngle;
    Serial.print("Servo manual a: ");
    Serial.println(manualTargetAngle);
  }
}
```

#### Cómo Funciona:
1. Usuario presiona botón "Manual" en la GUI
2. GUI envía comando `4:m` → Ground Station lo recibe
3. Ground Station activa `manualMode = true`
4. Potenciómetro ahora controla directamente el servo
5. Ground Station envía comandos `5:ángulo` cada 500ms si hay cambios
6. Satélite recibe y mueve el servo inmediatamente

---

### 2. **ALARMA DE TIMEOUT DE COMUNICACIÓN** ✅

#### Problema Original:
- Se perdió la alarma visual cuando se interrumpe la comunicación LoRa
- No había indicación clara de pérdida de señal

#### Solución Implementada:

**En SATÉLITE:**
```cpp
// Nuevas variables
const uint8_t ALARM_LED_PIN = 13;  // LED de alarma
unsigned long lastCommandReceived = 0;
const unsigned long COMM_TIMEOUT = 30000;  // 30 segundos
bool commTimeout = false;
bool alarmState = false;
unsigned long lastAlarmToggle = 0;
const unsigned long ALARM_BLINK_INTERVAL = 500;  // Parpadeo de 500ms

// Nueva función
void updateCommTimeout() {
  unsigned long now = millis();
  
  if (now - lastCommandReceived > COMM_TIMEOUT) {
    if (!commTimeout) {
      commTimeout = true;
      Serial.println("¡ALARMA! Timeout de comunicación");
    }
    
    // Parpadear LED de alarma
    if (now - lastAlarmToggle > ALARM_BLINK_INTERVAL) {
      alarmState = !alarmState;
      digitalWrite(ALARM_LED_PIN, alarmState ? HIGH : LOW);
      lastAlarmToggle = now;
    }
  } else {
    // Comunicación OK - apagar alarma
    if (commTimeout) {
      commTimeout = false;
      Serial.println("Comunicación restaurada");
    }
    digitalWrite(ALARM_LED_PIN, LOW);
  }
}
```

**En GROUND STATION:**
```cpp
// Nuevas variables
int alarmpin = 13;
const unsigned long timeout = 20000;  // 20 segundos
bool timeoutAlarm = false;
bool alarmState = false;
const unsigned long ALARM_BLINK_INTERVAL = 300;  // Parpadeo más rápido

// Nueva función
void updateTimeoutAlarm() {
  unsigned long now = millis();
  
  if (now - lastReceived > timeout) {
    if (!timeoutAlarm) {
      timeoutAlarm = true;
      Serial.println("¡ALARMA! TIMEOUT: sin datos del satélite");
    }
    
    // Parpadear LED de alarma
    if (now - lastAlarmToggle > ALARM_BLINK_INTERVAL) {
      alarmState = !alarmState;
      digitalWrite(alarmpin, alarmState ? HIGH : LOW);
      lastAlarmToggle = now;
    }
  } else {
    if (timeoutAlarm) {
      timeoutAlarm = false;
      Serial.println("Comunicación restaurada");
    }
    digitalWrite(alarmpin, LOW);
  }
}
```

#### Cómo Funciona:
1. Cada vez que llega un mensaje válido → actualiza `lastReceived` / `lastCommandReceived`
2. Si pasan 20s (GS) o 30s (SAT) sin mensajes → activa alarma
3. LED parpadea para indicar pérdida de comunicación
4. Cuando se restaura → LED se apaga automáticamente
5. Mensajes de debug en Serial para diagnóstico

---

## CONEXIONES DE HARDWARE REQUERIDAS

### Ground Station:
```
Pin A0  → Potenciómetro (entrada analógica)
Pin 2   → LED de error de checksum
Pin 13  → LED de alarma de timeout (NUEVO)
Pin 10  → RX del módulo LoRa
Pin 11  → TX del módulo LoRa
```

### Satélite:
```
Pin 12  → LED de transmisión (parpadea al enviar)
Pin 13  → LED de alarma de timeout (NUEVO)
Pin 5   → Servo motor
Pin 2   → Sensor DHT11
Pins 3-4 → Sensor ultrasónico
Pins 6,7,8,9 → Motor stepper (panel solar)
Pin A1  → Fotorresistor (luz para panel)
```

---

## FLUJO DE OPERACIÓN - MODO MANUAL

```
┌─────────────────┐
│   GUI Python    │
│ (botón Manual)  │
└────────┬────────┘
         │ envía "4:m"
         ▼
┌─────────────────┐
│  Ground Station │
│ manualMode=true │
└────────┬────────┘
         │
         │ cada 500ms:
         │ lee potenciómetro
         │ envía "5:ángulo"
         ▼
┌─────────────────┐
│    Satélite     │
│ recibe "5:90"   │
│ mueve servo→90° │
└─────────────────┘
```

---

## PRUEBAS RECOMENDADAS

### Test 1: Modo Manual
1. Cargar códigos en ambos Arduinos
2. Abrir monitor serial de Ground Station
3. Enviar comando: `4:m`
4. Verificar mensaje: "Modo MANUAL desde comando"
5. Girar potenciómetro
6. Verificar envío de comandos: "GS-> 5:XX*YY"
7. Verificar en satélite: "Servo manual a: XX"
8. Observar movimiento del servo

### Test 2: Timeout de Comunicación
1. Sistema funcionando normalmente
2. Desconectar cable TX del LoRa del satélite
3. Esperar 30 segundos
4. Verificar:
   - LED pin 13 parpadea en satélite
   - Mensaje "¡ALARMA! Timeout de comunicación"
5. Reconectar cable
6. Verificar:
   - LED se apaga
   - Mensaje "Comunicación restaurada"

### Test 3: Cambio de Modos
1. Sistema en modo AUTO (servo barriendo)
2. Enviar `4:m` (cambiar a manual)
3. Servo debe detenerse
4. Mover potenciómetro → servo responde
5. Enviar `4:a` (volver a auto)
6. Servo debe reanudar barrido automático

---

## MENSAJES DE DEBUG ÚTILES

### Ground Station:
```
"GS LISTO (protocolo binario + modo manual potenciómetro + timeout)"
"Modo AUTO desde comando"
"Modo MANUAL desde comando"
"Potenciómetro manual: 90"
"¡ALARMA! TIMEOUT: sin datos del satélite"
"Comunicación restaurada"
```

### Satélite:
```
"SAT listo (binario + Stepper + Timeout restaurado)"
"Modo AUTO activado"
"Modo MANUAL activado"
"Servo manual a: 90"
"¡ALARMA! Timeout de comunicación"
"Comunicación restaurada"
```

---

## NOTAS IMPORTANTES

1. **Prioridad del Stepper**: La función `updateStepper()` se ejecuta primero en cada ciclo del loop para mantener el movimiento suave del panel solar

2. **No-Bloqueante**: Todas las alarmas y funciones son no-bloqueantes para no interferir con la telemetría binaria

3. **Frecuencia del Potenciómetro**: Se lee cada 500ms en lugar de 20s para respuesta más rápida en modo manual

4. **Histéresis del Potenciómetro**: Solo envía cambios de ±2° para evitar jitter y spam de comandos

5. **Timeouts Diferentes**: 
   - Ground Station: 20s (recibe telemetría frecuente)
   - Satélite: 30s (recibe comandos menos frecuentes)

6. **Compatibilidad**: Los cambios son 100% compatibles con el protocolo binario existente y el sistema de tokens

---

## TROUBLESHOOTING

### Problema: Potenciómetro no mueve el servo
- ✓ Verificar que se envió comando `4:m`
- ✓ Verificar en serial: "Modo MANUAL activado"
- ✓ Verificar conexión del potenciómetro en A0
- ✓ Verificar que llegan comandos "5:XX"

### Problema: Alarma no se activa
- ✓ Verificar conexión del LED en pin 13
- ✓ Verificar timeouts (20s GS, 30s SAT)
- ✓ Verificar que se actualiza `lastReceived`/`lastCommandReceived`

### Problema: Servo no responde en modo manual
- ✓ Verificar que `autoDistance = false`
- ✓ Verificar que servo está en pin 5
- ✓ Verificar alimentación del servo (5V/1A mínimo)
- ✓ Verificar en serial: "Servo manual a: XX"

---

## VERSIÓN
- Fecha: Diciembre 2024
- Versión: FINAL_v1.0
- Características: Modo manual + Timeout restaurados
- Protocolo: Binario + ASCII híbrido
- Compatible con: GUI Python + Sistema de tokens
